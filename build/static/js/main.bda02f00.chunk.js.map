{"version":3,"sources":["Components/RestaurantCard.js","indexedDb.js","Components/Restaurants.js","App.js","serviceWorker.js","index.js"],"names":["highlight","term","string","reg","RegExp","split","map","token","index","Fragment","key","toLowerCase","style","color","RestaurantCard","props","className","id","name","group","address","street","city","rating","text","cuisines","item","cuisineName","trim","MyDB","version","storeName","this","db","undefined","connect","bind","addItems","upgradeNeeded","Promise","resolve","reject","a","request","indexedDB","open","onerror","event","console","log","onupgradeneeded","target","result","onsuccess","mode","transaction","objectStore","items","store","_getStoreTransaction","colorMapping","forEach","restaurantId","restaurantName","locality","ratingColor","ratingText","aggregateRating","newItem","average","put","callback","next","indexes","hasNext","i","indexName","indexNumber","findIndex","openCursor","IDBKeyRange","lowerBound","cursor","find","k","match","push","value","continue","nextIndexName","response","mydb","dbLib","oncomplete","objectStoreNames","contains","createObjectStore","keyPath","createIndex","unique","restaurantData","window","getRestaurants","options","then","search","catch","error","Restaurants","useState","isSearching","setIsSearching","nextCursor","totalResultFetched","list","groups","restaurants","setRestaurants","observerEntry","setEntry","elRef","useRef","useEffect","current","observer","IntersectionObserver","entries","threshold","observe","disconnect","restaurantList","prev","groupName","newGroups","Object","assign","length","isIntersecting","keys","groupHeading","restaurant","ref","App","searchTerm","setSearchTerm","pseudo","setPseudo","debounced","debounce","replace","eliminate","TextField","autoFocus","fullWidth","label","placeholder","onChange","variant","InputLabelProps","shrink","Boolean","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"mnxyIAGA,SAASA,EAAUC,EAAMC,GACxB,IAAMC,EAAM,IAAIC,OAAJ,WAAeH,EAAf,KAAwB,MACpC,OAAOC,EAAOG,MAAMF,GAAKG,KAAI,SAACC,EAAOC,GAAR,OAC5B,kBAAC,IAAMC,SAAP,CAAgBC,IAAG,UAAKF,IAErBD,EAAMI,gBAAkBV,EAAKU,cAC5B,0BAAMC,MAAO,CAACC,MAAO,QAASN,GAE/BA,MA0DUO,MArDf,SAAwBC,GACvB,OACI,wBACCC,UAAU,OACVN,IAAG,qBAAgBK,EAAME,GAAtB,YAA4BF,EAAMG,OAExC,wBAAIF,UAAU,QAEI,SAAhBD,EAAMI,MACNnB,EAAUe,EAAMd,KAAMc,EAAMG,MAC5BH,EAAMG,MAGR,uBAAGF,UAAU,WAEK,SAAhBD,EAAMI,MACNnB,EACCe,EAAMd,KADE,UAELc,EAAMK,QAAQC,OAFT,aAEoBN,EAAMK,QAAQE,OAH3C,UAKGP,EAAMK,QAAQC,OALjB,aAK4BN,EAAMK,QAAQE,OAG5C,yBAAKN,UAAU,UACd,kBAAC,IAAD,CACCA,UAAU,OACVJ,MAAO,CACNC,MAAOE,EAAMQ,OAAOV,OAAS,iBAG/B,0BAAMG,UAAU,QAAQD,EAAMQ,OAAOC,OAGtC,wBAAIR,UAAU,oBAEZD,EAAMU,SAASpB,MAAM,KAAKC,KAAI,SAACoB,EAAMlB,GACpC,IAAMmB,EAAcD,EAAKE,OACzB,OACC,wBAAIlB,IAAG,mBAAcF,EAAd,YAAuBmB,IAEZ,SAAhBZ,EAAMI,MACNnB,EAAUe,EAAMd,KAAM0B,GACtBA,S,iDCxDHE,E,WACL,WAAYX,EAAMY,EAASC,GAAY,oBACtCC,KAAKd,KAAOA,EACZc,KAAKF,QAAUA,EACfE,KAAKD,UAAYA,EACjBC,KAAKC,QAAKC,EAEVF,KAAKG,QAAUH,KAAKG,QAAQC,KAAKJ,MACjCA,KAAKK,SAAWL,KAAKK,SAASD,KAAKJ,M,oDAG5BM,GAAgB,IAAD,OACtB,OAAO,IAAIC,QAAJ,uCAAY,WAAOC,EAASC,GAAhB,eAAAC,EAAA,uDACZC,EAAUC,UAAUC,KAAK,EAAK3B,KAAM,EAAKY,UACvCgB,QAAU,SAACC,GAClBC,QAAQC,IAAI,QAASF,IAGlBT,GAA0C,oBAAlBA,IAC3BK,EAAQO,gBAAkB,SAACH,GAC1BC,QAAQC,IAAI,WACZX,EAAcS,EAAMI,OAAOC,QAAQ,WAClC,EAAKnB,GAAKc,EAAMI,OAAOC,YAK1BT,EAAQU,UAAY,SAACN,GACpB,EAAKd,GAAKc,EAAMI,OAAOC,OACvBJ,QAAQC,IAAI,WACZT,EAAQ,IAlBS,2CAAZ,2D,2CAuBac,GACpB,OAAOtB,KAAKC,GAAGsB,YAAYvB,KAAKD,UAAWuB,GAC1CE,YAAYxB,KAAKD,a,+BAGV0B,GACR,IAAMC,EAAQ1B,KAAK2B,qBAAqB,aAClCC,EAAe,CACpB,IAAO,UACP,OAAU,UACV,OAAU,UACV,MAAS,UACT,aAAc,WAGfH,EAAMI,SAAQ,SAAAnC,GAAS,IAEPT,EAQXS,EARHoC,aACgB5C,EAObQ,EAPHqC,eACAzC,EAMGI,EANHJ,KACA0C,EAKGtC,EALHsC,SACAC,EAIGvC,EAJHuC,YACAC,EAGGxC,EAHHwC,WACAC,EAEGzC,EAFHyC,gBACA1C,EACGC,EADHD,SAGK2C,EAAU,CACfnD,KACAC,OACAE,QAAS,CACRE,OACAD,OAAQ2C,GAETzC,OAAQ,CACPV,MAAO+C,EAAaK,IAAgB,UACpCzC,KAAM0C,EACNG,QAASF,GAEV1C,YAEDiC,EAAMY,IAAIF,Q,6BAILnE,E,EAAgCsE,GAAW,IAAD,OAAlCC,EAAkC,EAAlCA,KACRC,GAD0C,EAA5BtD,MAA4B,EAArBuD,QACX,CAAC,OAAQ,SACzB,OAAO,IAAInC,SAAQ,SAACC,EAASC,GAC5B,IAAIkC,EAAI,EACJlB,EAAQ,GAERtD,EAAM,IAAIC,OAAJ,WAAeH,EAAf,KAAwB,MAE9ByD,EAAQ,EAAKC,qBAAqB,YAElCiB,EAAaJ,GAAQA,EAAKhE,OAAkB,KAATP,EAAeuE,EAAKhE,MAAQ,OAC/DqE,EAAcJ,EAAQK,WAAU,SAAAH,GAAC,OAAIA,IAAMC,MAE3BJ,GAAQA,EAAK9D,IAChCgD,EAAMlD,MAAMoE,GAAWG,WAAWC,YAAYC,WAAWT,EAAK9D,MAC9DgD,EAAMlD,MAAMoE,GAAWG,cAEZ1B,UAAY,SAASN,GAChC,IAAImC,EAASnC,EAAMI,OAAOC,OAC1B,GAAI8B,GAAUP,EAdH,IAeG,KAAT1E,GAAyB,KAATA,GAAeiF,EAAOxE,IAAIyE,MAAK,SAAAC,GAAC,OAAIA,EAAEC,MAAMlF,SAC/DwE,IACAlB,EAAM6B,KAAKJ,EAAOK,QAGnBL,EAAOM,eACD,CACN,IAAMC,EAAyB,KAATxF,GAAewE,EAAQI,EAAY,GAAKJ,EAAQI,EAAY,QAAK3C,EACjFwC,IAAUQ,KAAiBO,EAC3BjB,EAAO,CACZ9D,IAAKwE,GAAUA,EAAOxE,IACtBF,MAAO0E,EAASN,EAAYa,GAGvBC,EAAW,CAChBjC,QACAyB,OAAQ,CACP/D,MAAOyD,EACPF,UACAzE,OACAuE,SAIED,GAAUA,EAAS,KAAMmB,GAC7BlD,EAAQkD,Y,KAOPC,EAAO,sBAAC,4BAAAjD,EAAA,4DACG,SACG,IACA,cAEbkD,EAAQ,IAAI/D,EAJF,SACG,IACA,eAHN,SAMP+D,EAAMzD,SAAQ,SAACF,EAAI4D,GACxB,IAAK5D,EAAG6D,iBAAiBC,SAASH,EAAM7D,WAAY,CACnD,IAAI2B,EAAQzB,EAAG+D,kBAAkBJ,EAAM7D,UAAW,CAAEkE,QAAS,OAE7DvC,EAAMwC,YAAY,OAAQ,CAAC,KAAM,WAAY,eAAgB,kBAAmB,CAAEC,QAAQ,IAC1FzC,EAAMwC,YAAY,OAAQ,CAAC,KAAM,QAAS,CAAEC,QAAQ,IACpDzC,EAAMH,YAAYsC,WAAlB,uCAA+B,WAAO9C,GAAP,SAAAL,EAAA,0DAC1BmD,GAAoC,oBAAfA,EADK,gCAC4BA,IAD5B,OAE9BD,EAAMvD,SAAS+D,GAFe,2CAA/B,0DAZW,cAmBbC,OAAOT,MAAQA,EAnBF,kBAoBNA,GApBM,0CAAD,GAuBb,SAASU,EAAerG,EAAMsG,EAAShC,GACtC,OAAOoB,EAAKa,MAAK,SAAAZ,GAChB,OAAOA,EAAMa,OAAOxG,EAAMsG,MAE1BC,MAAK,SAAApD,GAEL,OADImB,GAAUA,EAAS,KAAMnB,GACtBA,KAEPsD,OAAM,SAAAC,GAGN,OAFA3D,QAAQ2D,MAAM,UAAWA,GACrBpC,GAAUA,EAASoC,EAAO,MACvB,MAcM,OACdF,OAXD,SAAgBxG,EAAMsE,GACrB+B,EAAerG,EAAM,GAAIsE,IAWzBC,KAPD,WAA4CD,GAC3C+B,EADqD,EAAvCrG,KACO,CAACuE,KAD+B,EAAjCA,KACQrD,MADyB,EAA3BA,MACSuD,QADkB,EAApBA,SACYH,K,yjBCxC/BqC,MArIf,SAAqB7F,GAAQ,IAAD,EAEW8F,oBAAS,GAFpB,mBAEpBC,EAFoB,KAEPC,EAFO,OAGcF,mBAAS,CAC9CC,aAAa,EACVE,WAAY,CACRxC,KAAM,KACNvE,KAAM,GACNyE,SAAS,EACTvD,WAAOe,GAEX+E,mBAAoB,EACpB9F,WAAOe,EACPgF,KAAM,GACNC,OAAQ,KAdY,mBAGjBC,EAHiB,KAGJC,EAHI,OAgBUR,mBAAS,IAhBnB,mBAgBjBS,EAhBiB,KAgBFC,EAhBE,KAiBlBC,EAAQC,mBAqEjB,OAlEGC,qBAAU,WACN,GAAIF,EAAMG,QAAS,CAElB,IAAMC,EAAW,IAAIC,sBACjB,SAAAC,GAAO,OAAIP,EAASO,EAAQ,MAC5B,CAAEC,UAAW,IAIjB,OADAH,EAASI,QAAQR,EAAMG,SAChB,kBAAMC,EAASK,iBAExB,CAACb,EAAYJ,WAAWtC,UAI3BgD,qBAAU,WACTX,GAAe,GACfmB,EAAezB,OAAO1F,EAAM0F,QAAU,IAAI,SAACE,EAAOvD,GAC9CiE,GAAe,SAAAc,GACd,IAAMC,EAAYhF,EAAO8B,OAAO/D,MAC1BkH,EAAYC,OAAOC,OAAO,GAAdD,OAAA,IAAAA,CAAA,GAChBF,EAAYhF,EAAOK,QAGlB,OAAO,EAAP,GACO0E,EADP,CAEIjB,KAAM9D,EAAOK,MACbuD,WAAY5D,EAAO8B,OACnBiC,OAAQkB,EACRpB,mBAAoB7D,EAAOK,MAAM+E,YAIzCzB,GAAe,QAEjB,CAAChG,EAAM0F,SAEViB,qBAAU,WAELJ,EAAcmB,gBACdrB,EAAYJ,WAAWtC,SACvB0C,EAAYJ,WAAWxC,OACtBsC,IAEJC,GAAe,GACZmB,EAAe1D,KAAK4C,EAAYJ,YAAY,SAACL,EAAOvD,GAChDiE,GAAe,SAAAc,GACd,IAAMC,EAAYhF,EAAO8B,OAAO/D,MAC1BkH,EAAYC,OAAOC,OAAO,GAAIJ,EAAKhB,OAAvBmB,OAAA,IAAAA,CAAA,GAChBF,EADgB,UAAAE,OAAA,IAAAA,CACCH,EAAKhB,OAAOiB,IAAc,IAD3BE,OAAA,IAAAA,CACmClF,EAAOK,UAG5D,OAAO,EAAP,GACO0E,EADP,CAEIjB,KAAK,GAAD,mBAAMiB,EAAKjB,MAAX,YAAoB9D,EAAOK,QAC/BuD,WAAY5D,EAAO8B,OACnBiC,OAAQkB,EACRpB,mBAAoBkB,EAAKlB,mBAAqB7D,EAAOK,MAAM+E,YAIzEzB,GAAe,SAGZ,CAACO,EAAcmB,eAAgB3B,EAAaM,EAAYJ,aAG7D,yBAAKhG,UAAU,iBAEbsH,OAAOI,KAAKtB,EAAYD,QAAQ7G,KAAI,SAACI,EAAKF,GACzC,IAAM0G,EAAOE,EAAYD,OAAOzG,GAC1BiI,EAAezB,EAAKsB,OAAS,EAClC,yBACC9H,IAAG,eAAUA,EAAV,YAAiBF,GACpBQ,UAAU,gBACTN,GACC,KAaJ,OAXkBwG,EAAKsB,OAAS,GAC/B,wBAAIxH,UAAU,OAAON,IAAG,eAAUF,IAC/BO,EAAM0F,OAASkC,EAAe,KAE/BzB,EAAK5G,KAAI,SAAAsI,GACI,OAAO9H,EAAe,EAAD,GAAK8H,EAAL,CAAiB3I,KAAMc,EAAM0F,OAAQtF,MAAOT,YAUnF,yBAAKM,UAAU,mBAEPoG,EAAYJ,WAAWtC,QACvB,yBAAKmE,IAAKrB,GAAV,WAIN,6BAEqC,IAAnCJ,EAAYH,mBACZ,kBACA,sBC/EQ6B,MApCf,WAAgB,IAAD,EACyBjC,mBAAS,IADlC,mBACJkC,EADI,KACQC,EADR,OAEiBnC,mBAAS,IAF1B,mBAEJoC,EAFI,KAEIC,EAFJ,KAILC,EAAY1B,iBAAO2B,KAAS,SAAC7D,GAC/B2D,EAXR,SAAmBhJ,GACf,IAAMC,EAAM,IAAIC,OAAO,oBAAqB,MAC5C,OAAOF,EAAOmJ,QAAQlJ,EAAK,IASbmJ,CAAU/D,MACrB,MASH,OAPAmC,qBAAU,WACNyB,EAAUxB,QAAQoB,KACnB,CAACA,IAMA,yBAAK/H,UAAU,OACX,yBAAKA,UAAU,UACX,kBAACuI,EAAA,EAAD,CACIC,WAAS,EACTC,WAAS,EACTC,MAAM,qBACNC,YAAY,GACZpE,MAAOwD,EACPa,SAZhB,SAAsB7G,GAClBiG,EAAcjG,EAAMI,OAAOoC,QAYfsE,QAAQ,WACRC,gBAAiB,CACbC,QAAQ,MAIpB,kBAAC,EAAD,CAAatD,OAAQwC,MCjCbe,QACW,cAA7B3D,OAAO4D,SAASC,UAEe,UAA7B7D,OAAO4D,SAASC,UAEhB7D,OAAO4D,SAASC,SAAS7E,MACvB,2DCZN8E,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMjE,MAAK,SAAAkE,GACjCA,EAAaC,kB","file":"static/js/main.bda02f00.chunk.js","sourcesContent":["import React from 'react';\nimport StarIcon from '@material-ui/icons/Star';\n\nfunction highlight(term, string) {\n\tconst reg = new RegExp(`(${term})`, 'gi');\n\treturn string.split(reg).map((token, index) => (\n\t\t<React.Fragment key={`${index}`}>\n\t\t\t{\n\t\t\t\t(token.toLowerCase() === term.toLowerCase()) ?\n\t\t\t\t\t(<span style={{color: 'red'}}>{token}</span>)\n\t\t\t\t\t:\n\t\t\t\t\ttoken\n\t\t\t}\n\t\t</React.Fragment>\n\t))\n}\nfunction RestaurantCard(props) {\n\treturn (\n\t    <li\n\t\t    className=\"item\"\n\t\t    key={`restaurant-${props.id}-${props.name}`}\n\t    >\n\t\t\t<h5 className='name'>\n\t\t\t\t{\n\t\t\t\t\tprops.group === 'name' ?\n\t\t\t\t\thighlight(props.term, props.name) :\n\t\t\t\t\tprops.name\n\t\t\t\t}\n\t\t\t</h5>\n\t\t\t<p className='address'>\n\t\t\t\t{\n\t\t\t\t\tprops.group === 'meta' ?\n\t\t\t\t\thighlight(\n\t\t\t\t\t\tprops.term,\n\t\t\t\t\t\t`${props.address.street}, ${props.address.city}`\n\t\t\t\t\t) :\n\t\t\t\t\t`${props.address.street}, ${props.address.city}`\n\t\t\t\t}\n\t\t\t</p>\n\t\t\t<div className='rating'>\n\t\t\t\t<StarIcon\n\t\t\t\t\tclassName='icon'\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tcolor: props.rating.color || 'transparent'\n\t\t\t\t\t}}\n\t\t\t\t/>\n\t\t\t\t<span className='text'>{props.rating.text}</span>\n\t\t\t</div>\n\n\t\t\t<ul className='cuisineContainer'>\n\t\t\t\t{\n\t\t\t\t\tprops.cuisines.split(',').map((item, index) => {\n\t\t\t\t\t\tconst cuisineName = item.trim();\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<li key={`cuisines-${index}-${cuisineName}`}>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tprops.group === 'meta' ?\n\t\t\t\t\t\t\t\t\thighlight(props.term, cuisineName) :\n\t\t\t\t\t\t\t\t\tcuisineName\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t</ul>\n\t\t</li>\n\t)\n}\n\nexport default RestaurantCard;","import restaurantData from './data/json/zomato.json';\n\nclass MyDB {\n\tconstructor(name, version, storeName) {\n\t\tthis.name = name;\n\t\tthis.version = version;\n\t\tthis.storeName = storeName;\n\t\tthis.db = undefined;\n\n\t\tthis.connect = this.connect.bind(this);\n\t\tthis.addItems = this.addItems.bind(this);\n\t}\n\n\tconnect(upgradeNeeded) {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tconst request = indexedDB.open(this.name, this.version);\n\t\t\trequest.onerror = (event) => {\n\t\t\t\tconsole.log('error', event);\n\t\t\t}\n\n\t\t\tif (upgradeNeeded && typeof upgradeNeeded === 'function') {\n\t\t\t\trequest.onupgradeneeded = (event) => {\n\t\t\t\t\tconsole.log('upgrade');\n\t\t\t\t\tupgradeNeeded(event.target.result, () => {\n\t\t\t\t\t\tthis.db = event.target.result;\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.onsuccess = (event) => {\n\t\t\t\tthis.db = event.target.result;\n\t\t\t\tconsole.log('success');\n\t\t\t\tresolve(this);\n\t\t\t}\n\t\t})\n\t}\n\n\t_getStoreTransaction(mode) {\n\t\treturn this.db.transaction(this.storeName, mode)\n\t\t.objectStore(this.storeName);\n\t}\n\n\taddItems(items) {\n\t\tconst store = this._getStoreTransaction('readwrite');\n\t\tconst colorMapping = {\n\t\t\t'Red': '#E53935',\n\t\t\t'Yellow': '#FDD835',\n\t\t\t'Orange': '#FB8C00',\n\t\t\t'Green': '#7CB342',\n\t\t\t'Dark Green': '#1B5E20',\n\t\t}\n\n\t\titems.forEach(item => {\n\t\t\tconst {\n\t\t\t\trestaurantId: id,\n\t\t\t\trestaurantName: name,\n\t\t\t\tcity,\n\t\t\t\tlocality,\n\t\t\t\tratingColor,\n\t\t\t\tratingText,\n\t\t\t\taggregateRating,\n\t\t\t\tcuisines\n\t\t\t} = item;\n\n\t\t\tconst newItem = {\n\t\t\t\tid,\n\t\t\t\tname,\n\t\t\t\taddress: {\n\t\t\t\t\tcity,\n\t\t\t\t\tstreet: locality\n\t\t\t\t},\n\t\t\t\trating: {\n\t\t\t\t\tcolor: colorMapping[ratingColor] || '#E1E1E1',\n\t\t\t\t\ttext: ratingText,\n\t\t\t\t\taverage: aggregateRating\n\t\t\t\t},\n\t\t\t\tcuisines\n\t\t\t}\n\t\t\tstore.put(newItem);\n\t\t})\n\t}\n\n\tsearch(term, { next, group, hasNext }, callback) {\n\t\tconst indexes = ['name', 'meta'];\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet i = 0;\n\t\t\tlet items = [];\n\t\t\tlet limit = 50;\n\t\t\tlet reg = new RegExp(`(${term})`, 'gi');\n\n\t\t\tlet store = this._getStoreTransaction('readonly');\n\n\t\t\tlet indexName = (next && next.index && term !== \"\") ? next.index : 'name';\n\t\t\tlet indexNumber = indexes.findIndex(i => i === indexName);\n\n\t\t\tconst storeCursor = next && next.key ?\n\t\t\t\tstore.index(indexName).openCursor(IDBKeyRange.lowerBound(next.key)) :\n\t\t\t\tstore.index(indexName).openCursor();\n\t\t\t\n\t\t\tstoreCursor.onsuccess = function(event) {\n\t\t\t\tlet cursor = event.target.result;\n\t\t\t\tif (cursor && i < limit) {\n\t\t\t\t\tif (term === '' || (term !== '' && cursor.key.find(k => k.match(reg)))) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\titems.push(cursor.value)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tconst nextIndexName = term !== \"\" && indexes[indexNumber+1] ? indexes[indexNumber+1] : undefined;\n\t\t\t\t\tconst hasNext = cursor ? true : (nextIndexName ? true : false);\n\t\t\t\t\tconst next = {\n\t\t\t\t\t\tkey: cursor && cursor.key,\n\t\t\t\t\t\tindex: cursor ? indexName : nextIndexName\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tconst response = {\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tcursor: {\n\t\t\t\t\t\t\tgroup: indexName,\n\t\t\t\t\t\t\thasNext,\n\t\t\t\t\t\t\tterm,\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (callback) callback(null, response);\n\t\t\t\t\tresolve(response);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nconst mydb = (async function() {\n\tconst DB_NAME = 'zomato';\n\tconst DB_VERSION = '1';\n\tconst STORE_NAME = 'restaurants';\n\n\tconst dbLib = new MyDB(DB_NAME, DB_VERSION, STORE_NAME);\n\tawait dbLib.connect((db, oncomplete) => {\n\t\tif (!db.objectStoreNames.contains(dbLib.storeName)) {\n\t\t\tlet store = db.createObjectStore(dbLib.storeName, { keyPath: \"id\" });\n\n\t\t\tstore.createIndex('meta', ['id', 'cuisines', 'address.city', 'address.street'], { unique: false });\n\t\t\tstore.createIndex('name', ['id', 'name'], { unique: false });\n\t\t\tstore.transaction.oncomplete = async (event) => {\n\t\t\t\tif (oncomplete && typeof oncomplete === 'function') await oncomplete();\n\t\t\t\tdbLib.addItems(restaurantData);\n\t\t\t}\n\t\t}\n\t})\n\t\n\twindow.dbLib = dbLib;\t\n\treturn dbLib;\n})()\n\nfunction getRestaurants(term, options, callback) {\n\treturn mydb.then(dbLib => {\n\t\treturn dbLib.search(term, options);\n\t})\n\t.then(result => {\n\t\tif (callback) callback(null, result);\n\t\treturn result;\n\t})\n\t.catch(error => {\n\t\tconsole.error('error: ', error);\n\t\tif (callback) callback(error, null);\n\t\treturn [];\n\t})\n}\n\nfunction search(term, callback) {\n\tgetRestaurants(term, {}, callback);\n\treturn;\n}\n\nfunction next({term, next, group, hasNext}, callback) {\n\tgetRestaurants(term, {next, group, hasNext}, callback);\n\treturn;\n}\n\nexport default {\n\tsearch,\n\tnext\n};","import React, { useState, useEffect, useRef } from 'react';\nimport RestaurantCard from './RestaurantCard';\n\nimport restaurantList from '../indexedDb';\n\nfunction Restaurants(props) {\n\n\tconst [isSearching, setIsSearching] = useState(true);\n    const [restaurants, setRestaurants] = useState({\n    \tisSearching: true,\n        nextCursor: {\n            next: null,\n            term: '',\n            hasNext: true,\n            group: undefined,\n        },\n        totalResultFetched: 0,\n        group: undefined,\n        list: [],\n        groups: {}\n    });\n    const [observerEntry, setEntry] = useState({});\n    const elRef = useRef();\n\n    // runs only once.\n    useEffect(() => {\n        if (elRef.current) {\n\t        // adding ref to loading element, so that whenever it comes in view, new items get loaded.\n\t        const observer = new IntersectionObserver(\n\t            entries => setEntry(entries[0]),\n\t            { threshold: 1 }\n\t        );\n\n\t        observer.observe(elRef.current);\n\t        return () => observer.disconnect();\n    \t}\n    }, [restaurants.nextCursor.hasNext])\n\n\n    // runs every time search term changes.\n    useEffect(() => {\n    \tsetIsSearching(true);\n    \trestaurantList.search(props.search || '', (error, result) => {\n\t        setRestaurants(prev => {\n\t        \tconst groupName = result.cursor.group;\n\t        \tconst newGroups = Object.assign({}, {\n\t        \t\t[groupName]: result.items\n\t        \t})\n\n\t            return {\n\t                ...prev,\n\t                list: result.items,\n\t                nextCursor: result.cursor,\n\t                groups: newGroups,\n\t                totalResultFetched: result.items.length\n\t            }\n\t        })\n\n\t        setIsSearching(false);\n\t    })\n    }, [props.search])\n\n    useEffect(() => {\n    \tif (\n\t        observerEntry.isIntersecting &&\n\t        restaurants.nextCursor.hasNext &&\n\t        restaurants.nextCursor.next &&\n\t        !isSearching\n\t    ) {\n\t    \tsetIsSearching(true);\n\t        restaurantList.next(restaurants.nextCursor, (error, result) => {\n\t            setRestaurants(prev => {\n\t            \tconst groupName = result.cursor.group;\n\t            \tconst newGroups = Object.assign({}, prev.groups, {\n\t            \t\t[groupName]: [...(prev.groups[groupName] || []), ...result.items]\n\t            \t})\n\n\t\t            return {\n\t\t                ...prev,\n\t\t                list: [...prev.list, ...result.items],\n\t\t                nextCursor: result.cursor,\n\t\t                groups: newGroups,\n\t\t                totalResultFetched: prev.totalResultFetched + result.items.length\n\t\t            }\n\t            })\n\t\t\t\t\n\t\t\t\tsetIsSearching(false);\n\t        });\n\t\t}\n    }, [observerEntry.isIntersecting, isSearching, restaurants.nextCursor])\n\n\treturn (\n\t\t<div className=\"listContainer\">\n\t\t\t{\n\t\t\t\tObject.keys(restaurants.groups).map((key, index) => {\n\t\t\t\t\tconst list = restaurants.groups[key];\n\t\t\t\t\tconst groupHeading = list.length > 0 ? (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tkey={`hola-${key}-${index}`}\n\t\t\t\t\t\t\tclassName='groupHeading'\n\t\t\t\t\t\t>{key}</div>\n\t\t\t\t\t) : null;\n\n\t\t\t\t\tconst groupList = list.length > 0 && (\n\t\t\t\t\t\t<ul className=\"list\" key={`list-${index}`}>\n\t\t\t\t\t\t\t{ props.search ? groupHeading : null }\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlist.map(restaurant => {\n\t\t\t\t                \treturn RestaurantCard({...restaurant, term: props.search, group: key})\n\t\t\t\t            \t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t)\n\n\t\t\t\t\treturn groupList;\n\t\t\t\t})\n\t\t\t}\n\t\t\t\n\t\t\t<div className=\"loaderContainer\">\n\t\t\t\t{\n\t\t        \trestaurants.nextCursor.hasNext ?\n\t\t        \t<div ref={elRef} >\n\t\t\t\t\t\tLoading\n\t\t\t\t\t</div>\n\t\t\t\t\t:\n\t\t\t\t\t<div>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trestaurants.totalResultFetched === 0 ?\n\t\t\t\t\t\t\t'No Result Found' :\n\t\t\t\t\t\t\t'No More Results'\n\t\t\t\t\t\t}\n\t\t\t\t\t</div>\n\t\t\t    }\n\t\t\t</div>\n\t    </div>\n\t)\n}\n\nexport default Restaurants;","import React, { useState, useEffect, useRef } from 'react';\nimport TextField from '@material-ui/core/TextField';\n// import throttle from 'lodash.throttle';\nimport debounce from 'lodash.debounce';\n\nimport './App.css';\nimport Restaurants from './Components/Restaurants';\n\nfunction eliminate(string) {\n    const reg = new RegExp(\"[^a-zA-Z0-9,\\\\s+]\", \"gi\");\n    return string.replace(reg, \"\");\n}\n\n// Main App\nfunction App() {\n    const [searchTerm, setSearchTerm] = useState(\"\");\n    const [pseudo, setPseudo] = useState(\"\");\n\n    const debounced = useRef(debounce((value) => {\n        setPseudo(eliminate(value))\n    }, 200));\n\n    useEffect(() => {\n        debounced.current(searchTerm)\n    }, [searchTerm])\n    \n    function handleChange(event) {\n        setSearchTerm(event.target.value);\n    }\n    return (\n        <div className=\"App\">\n            <div className=\"Search\">\n                <TextField\n                    autoFocus\n                    fullWidth\n                    label=\"Search Restaurants\"\n                    placeholder=\"\"\n                    value={searchTerm}\n                    onChange={handleChange}\n                    variant=\"outlined\"\n                    InputLabelProps={{\n                        shrink: true\n                    }}\n                />\n            </div>\n            <Restaurants search={pseudo} />\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n"],"sourceRoot":""}